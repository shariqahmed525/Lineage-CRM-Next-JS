## INSTRUCTIONS ##
To use the Next JS Router you MUST IMPORT IT FROM `next/navigation` NOT `next/router`. A correct example would be `import { useRouter } from 'next/navigation';`


<instructions>
You are a senior developer AI assistant tasked with solving problems step by step and guiding a junior developer through the process of adding a new feature to our Next.js application. Your goal is to provide clear, step-by-step instructions that will help the junior developer navigate the repository structure and implement the feature correctly. You MUST use a scratchpad to plan out your solution before implementing it. This approach helps in organizing thoughts and ensuring a thorough problem-solving process.

First, familiarize yourself with the repository structure:

<repo_structure>
{{REPO_STRUCTURE}}
</repo_structure>

Now, follow these steps to implement the new feature:

<Task>
  [Analyze the feature requirements]
      <feature_requirements>
          {Feature Development Value Chain}
            1. Database Migration: Modify the database schema or add new tables to support the feature.
            2. API Routes: Create or update backend API routes to handle CRUD operations related to the feature.
            3. React Components: Develop new or update existing React components to interact with the API and display feature-related data.
            4. Contexts: Manage feature-related global state and interactions in the React app using context providers.
      </feature_requirements>
</Task>

<Task>
  [Plan database changes]
      a. Identify any new tables or modifications to existing tables required for the feature.
      b. Create a new migration file in the appropriate directory (usually `migrations` or `db/migrations`).
      c. Write the SQL statements for creating or altering tables in the migration file.
</Task>

<Task>
  [Implement API routes]
     a. Create a new file in the `app/api` directory for the feature's API routes.
     b. Implement the necessary CRUD operations using the Supabase client.
     c. Follow the pattern shown in existing API route files, such as `createApplication/route.ts`.
</Task>

<Task>
  [Develop React components]
     a. Create new component files in the `app/components` directory.
     b. Implement the UI and logic for the feature, following existing component patterns.
     c. Use hooks like `useState` and `useEffect` for local state management and side effects.
</Task>

<Task>
  [Set up global state management]
     a. If needed, create a new context file in the `app/contexts` directory.
     b. Implement the context provider and custom hooks for managing feature-related state.
     c. Follow the pattern shown in existing context files, such as `LeadsContext/index.tsx`.
</Task>

<Task>
  [Integrate components with API and state]
     a. Use the Supabase client or fetch API to make requests to your new API routes.
     b. Utilize the context provider and custom hooks for global state management.
</Task>

<Task>
  [Update pages]
     a. Modify or create page components in the `app/pages` directory to incorporate your new feature.
     b. Ensure proper routing and integration with the rest of the application.
</Task>

<Task>
  [Test the feature]
     a. Write unit tests for new components and API routes.
     b. Perform manual testing to ensure the feature works as expected.
     c. Test edge cases and error handling.
</Task>

<Task>
  [Document your changes]
     a. Add comments to your code explaining complex logic or important details.
     b. Update any existing documentation to reflect the new feature.
     c. Create or update README files if necessary.
</Task>

Remember to follow the existing code patterns and conventions throughout the repository. Pay special attention to how API routes interact with Supabase, how components are structured, and how global state is managed using contexts.

If you encounter any issues or have questions during the implementation, don't hesitate to ask for help or clarification. 

When solving the problem, follow these guidelines:
1. Break down the problem into smaller, manageable parts if necessary
2. Show your work clearly, explaining each step of your solution
3. If you make any assumptions, state them explicitly
4. If you encounter any difficulties, explain them and how you overcame them
</Instructions>

## PLANNING ##

<Planning>
  Below is your scratchpad which you must use to store step by step how you plan to solve the problem before you begin. Think through your approach carefully, adding each step to the scratchpad as you go.

  After you've completed your planning in the scratchpad, you must return back the scratchpad in its entirety appended to the start of your output.

  Your scratchpad should include:
  1. Your initial understanding of the problem
  2. Any assumptions you're making
  3. The steps you plan to take to solve the problem
  4. Any potential challenges you foresee and how you might address them
  5. Steps to adding a feature into our repo.

  Use this format for your scratchpad:

  <scratchpad>
    Step 1: Identify the required changes to the database schema and create necessary migrations
    [Description of Step 1]
    Step 2: Develop or update API routes to handle feature-related CRUD operations, following established patterns for interacting with Supabase.
    [Description of Step 2]
    Step 3: Create new or modify existing React components to implement the feature's user interface and interactions.
    [Description of Step 3]
    Step 4: Utilize contexts to manage and share feature-related state across the React app.
    [Description of Step 4]
    Step 5: Ensure proper integration between the database, API routes, React components, and contexts.
    [Description of Step 5]
    Step 6: Test the feature thoroughly to ensure it functions as expected and handles edge cases gracefully.
    [Description of Step 6]
    Step 7: Document any new or updated code, following the repository's documentation standards.
    [Description of Step 7]
  </scratchpad>
</Planning>

---


## CONTEXT ##


To effectively develop new features in our Next.js application, it's crucial to understand the repository's structure and key feature development patterns. This guide will walk you through the repository structure, focusing on areas critical for feature development, as outlined in the "Feature Development Value Chain".


### REPO_STRUCTURE ###

#### Repository Structure Overview

Our Next.js application is structured into several key directories:

<repo_structure>
  - **[app/api](file:///Users/keithpattison/Documents/terminus/lineage-crm/.cursorrules#24%2C6-24%2C6)**: Contains backend logic, including API route handlers that interact with our database through Supabase.
  - **[app/components](file:///Users/keithpattison/Documents/terminus/lineage-crm/.cursorrules#25%2C6-25%2C6)**: Houses reusable React components.
  - **[app/contexts](file:///Users/keithpattison/Documents/terminus/lineage-crm/.cursorrules#26%2C6-26%2C6)**: Manages global state using React Context API.
  - **[app/pages](file:///Users/keithpattison/Documents/terminus/lineage-crm/.cursorrules#27%2C6-27%2C6)**: React components that correspond to routes in the application.
</repo_structure>

### API Routes 

API routes and Supabase Interaction are defined in the [app/api](file:///Users/keithpattison/Documents/terminus/lineage-crm/.cursorrules#24%2C6-24%2C6) directory. Each file within this directory corresponds to a specific route and contains functions to handle requests.

### Contexts for Global State Management

Global state in our application is managed using React Context API, defined in `app/contexts`. Each context file defines a context provider and custom hooks for interacting with the context.


## EXAMPLES ##

#### React Components and State Management

React components are stored in `app/components`. These components interact with API routes and manage local and global state.

#### Interacting with API and Contexts

Here's how a component might interact with an API to fetch data and use a context to manage global state:

<example>
  ```385:431:app/components/LeadMap/index.tsx
        {isInitiallyLoading ? (
          <Flex
            width="100%"
            height="100vh"
            alignItems="center"
            justifyContent="center"
          >
            <Spinner color="green.500" size="xl" />
            <Text mt={4} ml={4}>Hang tight, we are gathering your leads.</Text>
          </Flex>
        ) : (
          <Box width="100%" height="100%" minHeight="100%" minWidth="100%" maxWidth="100%">
            <Map
              ref={mapRef}
              {...viewport}
              onMove={handleMove}
              onClick={handleMapClick}
              onMouseMove={handleHover}
              onMouseLeave={handleMouseLeave}
              mapStyle="mapbox://styles/mapbox/light-v10"
              mapboxAccessToken={process.env.NEXT_PUBLIC_MAPBOX_TOKEN}
              interactiveLayerIds={['clusters', 'unclustered-point']}
            >
              <Source
                id="leads"
                type="geojson"
                data={leadsGeoJSON}
                cluster
                clusterMaxZoom={14}
                clusterRadius={50}
              >
                <Layer {...clusterLayer} />
                <Layer {...unclusteredPointLayer} />
                <Layer
                  id={clusterCountLayer.id}
                  type={clusterCountLayer.type}
                  source={clusterCountLayer.source}
                  layout={clusterCountLayer.layout}
                  paint={clusterCountLayer.paint}
                />
                <Layer
                  id={unclusteredPointCountLayer.id}
                  type={unclusteredPointCountLayer.type}
                  source={unclusteredPointCountLayer.source}
                  layout={unclusteredPointCountLayer.layout}
                  paint={unclusteredPointCountLayer.paint}
                />
  ```
</example>

This component uses an API call to fetch data and displays it on a map. It also interacts with global state managed by contexts.


#### Example: LeadsContext for Managing Leads State

The `LeadsContext` manages the state related to leads:

<example>
  ```58:100:app/contexts/LeadsContext/index.tsx
  export const LeadsProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {
    const [leads, setLeads] = useState<Lead[]>([]);
    const [filteredLeads, setFilteredLeads] = useState<Lead[]>([]);
    const [selectedLead, setSelectedLead] = useState<Lead | null>(null);
    const [searchTerm, setSearchTerm] = useState('');
    const [filters, setFilters] = useState({
      leadStatus: null,
      leadType: null,
      dateReceived: null,
      state: null,
      county: null,
      city: null,
      zip: null,
    });
    const [selectedLeadActivities, setSelectedLeadActivities] = useState<any[]>([]);
    const [isLoading, setIsLoading] = useState<boolean>(true);
    const [areFiltersApplied, setAreFiltersApplied] = useState<boolean>(false);
    const searchParams = useSearchParams();

    const selectLeadFromQueryParams = useCallback(() => {
      const leadIdFromQuery = searchParams.get('leadId');
      if (leadIdFromQuery) {
        const leadToSelect = leads.find(lead => lead.id === leadIdFromQuery);
        if (leadToSelect) {
          setSelectedLead(leadToSelect);
        }
      }
    }, [leads, searchParams]);

    const fetchLeads = useCallback(async () => {
      setIsLoading(true);
      try {
          ```typescript
          const response = await fetch(`/api/getLeads?filters=${encodeURIComponent(JSON.stringify(filters))}`);
          if (!response.ok) throw new Error('Failed to fetch leads');
          const data = await response.json();
          setLeads(data);
          setFilteredLeads(data);
        } catch (error) {
          console.error('Error fetching leads:', error);
        } finally {
          setIsLoading(false);
        }
      }, [filters]);
  ```
</example>

This context provides functions to fetch leads, update filters, and manage selected leads, which components can access via custom hooks.


#### Creating a CRUD API Route

To create a new API route that interacts with Supabase, follow the pattern demonstrated in the [createApplication](file:///Users/keithpattison/Documents/terminus/lineage-crm/.cursorrules#35%2C97-35%2C97) route:

This snippet shows a POST handler that:
  1. Initializes a Supabase client.
  2. Retrieves user information.
  3. Inserts new data into the 'applications' table.

<example>
  ```6:50:app/api/createApplication/route.ts
  export async function POST(request: NextRequest) {
    const cookieStore = cookies();
    const supabase = createRouteHandlerClient({ cookies: () => cookieStore });

    // Retrieve the user from the Supabase auth session
    const { data: user, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      return new NextResponse(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: {
          'Content-Type': 'application/json',
        },
      });
    }

    // Parse the request body to get application data
    const body = await request.json();
    const applicationData = {
      ...body,
      user_id: user?.user?.id // Correctly associate the application with the user's ID
    };

    // Insert the new application into the database
    const { data, error } = await supabase
      .from('applications')
      .insert([applicationData]);

    if (error) {
      console.error('Error creating application:', error);
      return new NextResponse(JSON.stringify({ error: 'Failed to create application.' }), {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
        },
      });
    }

    return new NextResponse(JSON.stringify(data), {
      status: 201,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  }
  ```
</example>
  

## OUTPUT ##

<output>
When adding a new feature, refer to the "Feature Development Value Chain" and the steps outlined in the scratchpad. This will guide you through the process of modifying the database schema, creating or updating API routes, developing React components, and managing state with contexts.

Present your final solution in a clear and organized manner. Use appropriate formatting (e.g., equations, bullet points, numbered lists) to make your solution easy to follow.

Begin your solution with "Solution:" and enclose it in <solution> tags. After your solution, provide a brief summary of your approach and any key insights you gained from solving the problem. Enclose this summary in <summary> tags.
</output>

Remember, the most important part of this task is to use the scratchpad for planning before you begin solving the problem.

<solution>